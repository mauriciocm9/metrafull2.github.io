<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Programacion funcional y logica</title><meta charset="UTF-8"></meta><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        showProcessingMessages: false,
        messageStyle: "none",
        TeX : { extensions : ['color.js'] }
      });
    </script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></head><body class="impress-not-supported"><div id="impress" data-transition-duration="0"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="hoja-presentacion">Hoja Presentacion:</h1><ul><li>Mauricio Cortazar</li><li>Programacion funcional y logica</li></ul></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="que-es-una-funcion">Que es una funcion?</h1><p>Se define funcion a aquel conjunto de instrucciones finitas que se ejecuta solo cuando es llamada (puede ser llamada multiple veces) y hace parte de una aplicacion mas grande.</p><p>Puede compararse con las funciones matematicas de tal forma que tenemos la funcion</p><div class="math-block ">$$\begin{align}f(x) = x^2\end{align}$$</div><p>La funcion anterior tiene un nombre(f), recive unos parametros(x) y retorna un valor de salida.</p><p>Las funciones en la programacion funcionan exactamente igual, a excepcion que no tengan parametros de entrada o no retornen algun valor.</p></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="recursividad">Recursividad</h1><p>Para entender el concepto de recursividad, tenemos que tener claro que son funciones y como funcionan. Primero veamos como luce la serie <em>fibonacci</em> con funciones matematicas:</p><div class="math-block ">$$\begin{align}T(n) =
\begin{cases}
                                 0 &amp; \text{if $n=0$} \\
                                 1 &amp; \text{if $n=1$} \\
T({n-1}) + T({n-2}) &amp; \text{if $n&gt;1$}
\end{cases}\end{align}$$</div><p>Dejemos de lado las funciones matematicas y usemos programacion para mostrar esta funcion recursiva en python:</p><pre class="highlight code python"><span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
          <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>
          <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">T</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">T</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span></pre><p>La palabra def corresponde a Define Function. Como observamos la funcion T retorna 0 cuando su parametro n es igual a 0, pasa igual cuando n es igual a 1, pero diferente a esos valores, la funcion T por un lado retorna la suma de la funciones T restando en 1 y 2 su argumento respectivamente.</p><p>Es recursiva por que T se llama a si misma sin parar hasta que una condicion la detenga. En este caso que su argumento(n) sea igual ya sea a 0 o a 1, de otra forma se ejecutaria infinitas veces colapsando la computadora</p></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="historia-lenguaje-funcional">Historia lenguaje funcional</h1><p>Todo empezo con Gottfried Leibniz, quien cre&#xF3; la m&#xE1;quina mec&#xE1;nica de c&#xE1;lculo en el siglo XVII. Esta m&#xE1;quina fue el primer prototipo del dispositivo so&#xF1;ado por Leibniz: una m&#xE1;quina capaz de manipular s&#xED;mbolos y determinar si una frase matem&#xE1;tica era o no un teorema, es decir, si una proposici&#xF3;n que part&#xED;a de un supuesto (hip&#xF3;tesis), afirmaba una verdad (tesis) que no es evidente por s&#xED; misma.</p><p>Para el a&#xF1;o de 1928, los matem&#xE1;ticos David Hilbert y Wilhelm Ackermann propusieron el problema de la decisi&#xF3;n, que consiste en encontrar un proceso o algoritmo (a&#xFA;n no se ten&#xED;a la definici&#xF3;n formal de algoritmo como tal) general, que decidiera si una f&#xF3;rmula de c&#xE1;lculo de primer orden es un teorema retomando la idea desarrollada por Leibniz.</p><p>En 1936, Alonzo Church desarroll&#xF3; la definici&#xF3;n formal de algoritmo bajo el concepto de &#x201C;calculabilidad efectiva&#x201D; y dise&#xF1;&#xF3; una soluci&#xF3;n al problema planteado por Hilbert y Ackermann utilizando un modelo de computaci&#xF3;n denominado por &#xE9;l mismo como C&#xE1;lculo Lambda, la base fundamental de este paradigma.</p><p>En este mismo a&#xF1;o, Alan Turing -al igual que Church- desarrollaba una definici&#xF3;n de algoritmo y daba soluci&#xF3;n al problema de la decisi&#xF3;n, pero usando las m&#xE1;quinas de Turing, otro modelo de computaci&#xF3;n que se convertir&#xED;a en la base de la computaci&#xF3;n actual, bajo un concepto completamente diferente al c&#xE1;lculo lambda: el problema de la parada. Cabe aclarar que los dos modelos computacionales son equivalentes ya que ambos pueden dar soluci&#xF3;n a los mismos tipos de problemas.</p><p>El paradigma funcional se empez&#xF3; a desarrollar por el matem&#xE1;tico John McCarthy en 1956, para programar los primeros proyectos de inteligencia artificial sobre un computador IBM 704, esto se realiz&#xF3; mediante la implementaci&#xF3;n de LISP en 1958, lenguaje que aunque no era puramente funcional(Primer lenguaje multiparadigma), todas las caracter&#xED;sticas introducidas por &#xE9;l, se convirtieron en las bases para lo que hoy llamamos Paradigma funcional.</p></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="enfoque-lenguaje-funcional">Enfoque lenguaje funcional</h1><p>Los lenguajes funcionales estan enfocados a manipulacion de estructuras de datos siendo estas modificadas a traves de expresiones y no a traves de declaraciones como lo hacen los lenguajes imperativos, se enfocan mas en hacer la tarea y no especificando el como.</p><p>Este nuevo enfoque te permite abstraer todas las declaraciones imperativas a un mas alto nivel pero te obligan a pensar a traves de funciones. Muchos lenguajes multiparadigma implementan este esquema funcional, por ejemplo python y muchos lenguajes mas soportan una caracteristica muy comun en los lenguajes funcionales como lo es map, filter, etc.</p><p>Tomemos por ejemplo una lista lista = [2, 3, 4] y queremos convertir todos sus valores internos en potencia de 2, imperativamente en python lo hariamos de esta manera:</p><pre class="highlight code python"><span class="n">lista</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">potencias</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">elemento</span> <span class="ow">in</span> <span class="n">lista</span><span class="p">:</span>
    <span class="n">potencias</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elemento</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">potencias</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">]</span></pre><p>Pero python tambien nos da la funcion map que nos permite hacerlo todo en una sola linea de codigo</p><pre class="highlight code python"><span class="n">lista</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">potencias</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">lista</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">potencias</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">]</span></pre></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="lista-de-lenguajes-funcionales-puros-e-hibridos">Lista de lenguajes funcionales puros e hibridos</h1><p>Algunos lenguajes funcionales puros son:</p><ul><li>Haskell</li><li>Mercury</li><li>Clean</li><li>Miranda</li><li>Disciple</li></ul><p>Lenguajes funcionales impuros:</p><ul><li>LISP</li><li>Clojure</li><li>F#</li><li>OCaml</li><li>Scheme</li><li>Scala</li></ul></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="algoritmos-con-paradigma-funcional">Algoritmos con paradigma funcional</h1><p>El paradigma funcional nos permite implementar a veces los mismos algoritmos que el paradigma imperativo solo que a traves de funciones. Como vimos la serie <em>fibonacci</em> la implementamos con funciones recursivas, pero tambien podemos implementarla sin funciones y en este caso el tiempo de ejecucion es mucho mejor:</p><pre class="highlight code python"><span class="k">while</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">n</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span></pre><p>Pero a veces la programacion funcional nos presenta alternativas que nos dan mejores resultados. Una de ellas es el famoso algoritmo merge-sort que se nos presenta de manera funcional recursiva y que hace parte de los mejores algoritmos de ordenamiento aqui el ejemplo:</p><pre class="highlight code python"><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">b</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">+=</span> <span class="n">b</span>
        <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">+=</span> <span class="n">a</span>
        <span class="k">return</span> <span class="n">c</span>

<span class="k">def</span> <span class="nf">mergesort</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
                <span class="n">middle</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">mergesort</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="n">middle</span><span class="p">])</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">mergesort</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">middle</span><span class="p">:])</span>
                <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">mergesort</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></pre></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="campos-de-aplicacion-de-la-programacion-funcional">Campos de aplicacion de la programacion funcional</h1><p>La programacion funcional es muy usada para el desarrollo de software donde el procesamiento de datos es uno de sus principales objetivos, por ejemplo en los sistemas financieros, Inteligencia Artificial(el proposito inicial de LISP era ese), computacion matematica, desarrollo de videojuegos.</p><p>Pero no podemos olvidarnos de la influencia que los lenguajes funcionales han aportado en los imperativos, como vimos anteriormente muchos lenguajes implementan la funcion <em>map</em> que tiene su procedencia de los lenguajes funcionales.</p></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="programacion-logica">Programacion Logica</h1><p>A diferencia de la programacion funcional donde es una evolucion de los predicados, en la programacion logica tratamos el concepto de cada predicado y la relacion entre cada predicado</p></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="que-es-la-logica-matematica">Que es la logica matematica?</h1><p>Para entender de que va la logica matematica podemos empezar buscando el significado de la logica. Wikipedia nos da lo siguiente: "M&#xE9;todo o razonamiento en el que las ideas o la sucesi&#xF3;n de los hechos se manifiestan o se desarrollan de forma coherente y sin que haya contradicciones entre ellas.". De acuerdo a lo anterior podemos inferir que la logica matematica busca la verdad a traves de razonamiento sin contradicciones.</p></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="que-es-una-proposicion-logica">Que es una proposicion logica?</h1><p>Una proposicion logica es una entidad portadora de verdad que se caracteriza por su valor logico y de razonamiento por ejemplo tenemos la frase:</p><blockquote><dl><dt>"Todos los hombres son mortales"</dt><dd><p>"Pedro es un hombre mortal"</p></dd></dl></blockquote><p>En los anteriores enunciados sabemos que la segunda proposicion es logica por que se desarrolla de acuerdo a la idea principal.</p><h1 id="que-es-un-teorema">Que es un teorema?</h1><p>Un teorema es una proposicion que afirma una verdad demostrable.</p></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="que-es-una-tabla-de-verdad">Que es una tabla de verdad?</h1><p>Una tabla de verdad es un grafico que nos permite visualizar el valor logico de proposiciones compuestas.</p><h1 id="que-es-un-axioma">Que es un axioma?</h1><p>A diferencia de un teorema, un axioma es una proposici&#xF3;n asumida dentro de un cuerpo te&#xF3;rico sobre la cual descansan otros razonamientos y proposiciones deducidas de esas premisas.</p><h1 id="que-es-una-tautologia">Que es una tautologia?</h1><p>Una tautolog&#xED;a es una f&#xF3;rmula bien formada que resulta verdadera para cualquier interpretaci&#xF3;n; es decir, para cualquier asignaci&#xF3;n de valores de verdad que se haga a sus f&#xF3;rmulas at&#xF3;micas.1&#x200B;2&#x200B; La construcci&#xF3;n de una tabla de verdad es un m&#xE9;todo efectivo para determinar si una f&#xF3;rmula cualquiera es una tautolog&#xED;a o no.</p><h1 id="leyes-de-morgan">Leyes de morgan</h1><p>En l&#xF3;gica proposicional y &#xE1;lgebra de Boole, las leyes de De Morgan1&#x200B;2&#x200B;3&#x200B; son un par de reglas de transformaci&#xF3;n que son ambas reglas de inferencia v&#xE1;lidas. Las normas permiten la expresi&#xF3;n de las conjunciones y disyunciones puramente en t&#xE9;rminos de v&#xED;a negaci&#xF3;n:</p><ul><li>&#xAC; es el operador de negaci&#xF3;n (NO)</li><li>^ es el operador de conjunci&#xF3;n (Y)</li><li>&#x2228; es el operador de disyunci&#xF3;n (O)</li><li>&#x21D4; es un s&#xED;mbolo metal&#xF3;gico que significa "puede ser reemplazado en una prueba l&#xF3;gica"</li></ul></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="historia-y-origenes-de-la-programacion-logica">Historia y origenes de la programacion logica</h1><p>La l&#xF3;gica matem&#xE1;tica es la manera m&#xE1;s sencilla de expresar formalmente problemas complejos y de resolverlos mediante la aplicaci&#xF3;n de reglas, hip&#xF3;tesis y teoremas, para el intelecto humano. De ah&#xED; que el concepto de "programaci&#xF3;n l&#xF3;gica". La l&#xF3;gica ha estado muy relacionada hist&#xF3;ricamente con las computadoras y los lenguajes de programaci&#xF3;n. Muchas operaciones matem&#xE1;ticas se realizan mec&#xE1;nicamente es decir que existe un algoritmo para resolverse. Otras, son m&#xE1;s dif&#xED;ciles de automatizar, por ejemplo, la demostraci&#xF3;n de un teorema. La invenci&#xF3;n del C&#xE1;lculo por parte de Newton y Leibniz mostr&#xF3; a los matem&#xE1;ticos de la &#xE9;poca c&#xF3;mo una notaci&#xF3;n adecuada pod&#xED;a hacer que operaciones muy complicadas se simplificaran, y surgi&#xF3; la idea de que "con una notaci&#xF3;n adecuada, toda la matem&#xE1;tica se puede hacer mec&#xE1;nica, podr&#xED;a concebirse una m&#xE1;quina que hiciera todo el trabajo". Los circuitos de las computadoras son dise&#xF1;ados con la ayuda del &#xE1;lgebra booleana (George Boole). Datos y expresiones booleanos son usados en casi todos los lenguajes de programaci&#xF3;n para el control de acciones del programa. Proposiciones l&#xF3;gicas se han usado para describir formalmente la sem&#xE1;ntica de los lenguajes de programaci&#xF3;n, seg&#xFA;n el m&#xE9;todo axiom&#xE1;tico que tuvo a Floyd y Hoare como iniciadores. Enunciados l&#xF3;gicos se usan para especificaciones formales que describen el comportamiento de un programa, lo que permite realizar sobre estas pruebas de correcci&#xF3;n.</p></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="bases-de-la-programacion-logica">Bases de la programacion logica</h1><p>Como hemos visto anteriormente la logica se basa en proposiciones que son verdades obtenidas a traves de un razonamiento. La programacion logica toma todo este modelo de sentencias de muy bajo nivel para su desarrollo, a diferencia de los lenguajes funcionales que como vimos se preocupan en tener las cosas hechas, el modelo logico se nos presenta en declarar cada sentencia que tengamos usando la logica formal. Tomemos nuevamente el ejemplo de pedro y su mortalidad, para poder llegar a la conclusion de que pedro es mortal, debemos leer las 2 setencias propuesta, la primera nos muestra que todos los hombres son mortales y la segunda que pedro es un hombre por lo tanto usando la logica formal inferimos que pedro es mortal.</p><p>Esta paradigma aunque parezca simple, nos presenta un metodo distinto a otros paradigmas ya sea por su capacidad de probar o resolver problemas donde el resultado tenga que ser totalmente cierto o falso es decir cuando queremos resultados absolutos.</p><p>Entre sus caracteristicas principales, el paradigma logico nos da una validacion de la informacion muy simple comparado con otros lenguajes.</p><p>En general, una regla de inferencia es s&#xF3;lo una instrucci&#xF3;n para obtener proposiciones verdaderas adicionales de una lista de proposiciones verdaderas.</p></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="clausula-de-horn">Clausula de Horn</h1><p>En l&#xF3;gica proposicional, una f&#xF3;rmula l&#xF3;gica es una cl&#xE1;usula de Horn si es una cl&#xE1;usula (disyunci&#xF3;n de literales) con, como m&#xE1;ximo, un literal positivo. Se llaman as&#xED; por el l&#xF3;gico Alfred Horn, el primero en se&#xF1;alar la importancia de estas cl&#xE1;usulas en 1951.</p><p>Una cl&#xE1;usula de Horn con exactamente un literal positivo es una cl&#xE1;usula "definite"; en &#xE1;lgebra universal las cl&#xE1;usulas "definites" resultan (aparecen) como cuasi-identidades. Una cl&#xE1;usula de Horn sin ning&#xFA;n literal positivo es a veces llamada cl&#xE1;usula objetivo (goal) o consulta (query), especialmente en programaci&#xF3;n l&#xF3;gica.</p><p>Una f&#xF3;rmula de Horn es una cadena textual (string) de cuantificadores existenciales o universales seguidos por una conjunci&#xF3;n de cl&#xE1;usulas de Horn.</p><pre class="highlight code prolog"><span class="nf">hija</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">)</span> <span class="p">:-</span> <span class="nf">mujer</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span> <span class="nf">padre</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">A</span><span class="p">).</span>


<span class="nf">likes</span><span class="p">(</span><span class="s-Atom">mary</span><span class="p">,</span><span class="s-Atom">food</span><span class="p">).</span>
<span class="nf">likes</span><span class="p">(</span><span class="s-Atom">mary</span><span class="p">,</span><span class="s-Atom">wine</span><span class="p">).</span>
<span class="nf">likes</span><span class="p">(</span><span class="s-Atom">john</span><span class="p">,</span><span class="s-Atom">wine</span><span class="p">).</span>
<span class="nf">likes</span><span class="p">(</span><span class="s-Atom">john</span><span class="p">,</span><span class="s-Atom">mary</span><span class="p">).</span>



<span class="p">|</span> <span class="s-Atom">?-</span> <span class="nf">likes</span><span class="p">(</span><span class="s-Atom">mary</span><span class="p">,</span><span class="s-Atom">food</span><span class="p">).</span>
<span class="s-Atom">yes</span><span class="p">.</span>
<span class="p">|</span> <span class="s-Atom">?-</span> <span class="nf">likes</span><span class="p">(</span><span class="s-Atom">john</span><span class="p">,</span><span class="s-Atom">wine</span><span class="p">).</span>
<span class="s-Atom">yes</span><span class="p">.</span>
<span class="p">|</span> <span class="s-Atom">?-</span> <span class="nf">likes</span><span class="p">(</span><span class="s-Atom">john</span><span class="p">,</span><span class="s-Atom">food</span><span class="p">).</span>
<span class="s-Atom">no</span><span class="p">.</span></pre></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>G</th><td>Go to slide number</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>